import math


def alignment(text: list[str], k: int) -> list[str]:
    """Функция выравнивает текст по значению k"""
    num_elements = len(text) # сколько элементов находится в заданном списке слов
    groups = 2 # начальное кол-во предложений(групп), на которые будет делить элементы
    len_one_element = k + 1 # задаём начальное значение для длины одного предложения
    final_list = [] # будем записывать сколько должно быть элементов в одном предложении
    while len_one_element > k: # пока длина одного предложения больше k 
        # сколько элементов должно быть в одном предложении(группе)
        # будем находить путь деления кол-во слов в пременной text на кол-во предложений(групп)
        # math.ceil - округление в большую строну
        elements_one_group = math.ceil(num_elements / groups) # сколько элементов в группе
        start = 0 # с какого элемента начнется срез
        stop = elements_one_group # на каком элементе закончится срез
        for i in range(groups): # для каждого предложения (группы):
            one_group_list = text[start:stop] # берем срез от первого слова группы до последнего
            # Смотрим сколько символов получилось в этом предложении(группе)
            # путем перевода среза one_group_list в строку через пробел
            # " ".join() - join с пробелом выполнит условие задачи, где
            # необходимо, чтобы между словами был минимум одни пробел
            # my_list = ['cat', 'frog', 'dog']
            # " ".join(my_list) --> "cat frog dog"
            len_one_element = len(" ".join(one_group_list)) # считаем сколько символов находится в группе
            # Если длина первого предложения получилась больше заданной, то
            # такое предложение нам не подходит, нам нужно получить большее кол-во групп(перменная groups),
            # чтобы в одном предложении оказалось меньше слов.
            # если длина предложения больше, то выходим из цикла for
            # добавляем к groups единицу, чтобы увеличить кол-во групп(предложений)
            # цикл while увидев, что len_one_element попрежнему < k, заново запускает
            # цикл for, но уже с другим кол-вом групп
            # нет смысла проверять остальные предложения(группы) их у нас, кстати, groups
            if len_one_element > k: 
                break
            # Если условие не сработало, тогда
            final_list.append(one_group_list) # в список добавляем группу подходящих слов
            start = stop # start берет начало следующего предложения
            stop += elements_one_group # stop конец следующего предложения
            # и цикл заново повторяется, то есть мы опять проверяем 
            # подходит ли нам len_one_element другого предложения
            
        groups += 1 # увеличиваем кол-во групп(groups)
        
    asignment_list = [] # задаем пустой список, в котором будет находится выровненный текст
    print(f'final_list = {final_list}')
    for text_element in final_list: # берем каждый элемент(предложение) в final_list
        # смотрим сколько символов находится в одном предложении
        # с учетом обязательных пробелов
        len_one_element = len(' '.join(text_element)) # сколько символов в предложении
        one_text = ' '.join(text_element) # переводим список слов в предложение
        while len_one_element != k: # пока длина символов не равняется k
            for i in range(len(text_element)): # для каждого слова в предложение
                if i != (len(text_element) - 1): # если это слово не последнее
                    text_element[i] += " " # добавляем к i-му слову пробел 
                    # переводим список с пробелами + обязательные пробелы в строку
                    one_text = ' '.join(text_element)
                    len_one_element = len(one_text) # записываем сколько символом в измененной строке
                if len(text_element) == 1: # Если предложение состоит из одного слова:
                    one_text += " " # добавляем к этому слову пробел
                    len_one_element = len(one_text) # записываем сколько символом в измененной строке
                # Если длина предложения станет k, то выходим из цикла k
                if len_one_element == k:
                    break
        # после цикла for добавляем окончательное предложение в список asignmnet_list
        asignment_list.append(one_text)
            
    return asignment_list
        
        
alignment(['the', 'quick', 'brown', 'fox', 'jumps', 'over', 'the', 'lazy', 'dog'], 16)